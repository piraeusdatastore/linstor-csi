// Code generated by mockery v2.12.3. DO NOT EDIT.

package mocks

import (
	context "context"

	client "github.com/LINBIT/golinstor/client"

	mock "github.com/stretchr/testify/mock"
)

// ResourceDefinitionProvider is an autogenerated mock type for the ResourceDefinitionProvider type
type ResourceDefinitionProvider struct {
	mock.Mock
}

// AttachExternalFile provides a mock function with given fields: ctx, resDefName, filePath
func (_m *ResourceDefinitionProvider) AttachExternalFile(ctx context.Context, resDefName string, filePath string) error {
	ret := _m.Called(ctx, resDefName, filePath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, resDefName, filePath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Clone provides a mock function with given fields: ctx, srcResDef, request
func (_m *ResourceDefinitionProvider) Clone(ctx context.Context, srcResDef string, request client.ResourceDefinitionCloneRequest) (client.ResourceDefinitionCloneStarted, error) {
	ret := _m.Called(ctx, srcResDef, request)

	var r0 client.ResourceDefinitionCloneStarted
	if rf, ok := ret.Get(0).(func(context.Context, string, client.ResourceDefinitionCloneRequest) client.ResourceDefinitionCloneStarted); ok {
		r0 = rf(ctx, srcResDef, request)
	} else {
		r0 = ret.Get(0).(client.ResourceDefinitionCloneStarted)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, client.ResourceDefinitionCloneRequest) error); ok {
		r1 = rf(ctx, srcResDef, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloneStatus provides a mock function with given fields: ctx, srcResDef, targetResDef
func (_m *ResourceDefinitionProvider) CloneStatus(ctx context.Context, srcResDef string, targetResDef string) (client.ResourceDefinitionCloneStatus, error) {
	ret := _m.Called(ctx, srcResDef, targetResDef)

	var r0 client.ResourceDefinitionCloneStatus
	if rf, ok := ret.Get(0).(func(context.Context, string, string) client.ResourceDefinitionCloneStatus); ok {
		r0 = rf(ctx, srcResDef, targetResDef)
	} else {
		r0 = ret.Get(0).(client.ResourceDefinitionCloneStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, srcResDef, targetResDef)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: ctx, resDef
func (_m *ResourceDefinitionProvider) Create(ctx context.Context, resDef client.ResourceDefinitionCreate) error {
	ret := _m.Called(ctx, resDef)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.ResourceDefinitionCreate) error); ok {
		r0 = rf(ctx, resDef)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateVolumeDefinition provides a mock function with given fields: ctx, resDefName, volDef
func (_m *ResourceDefinitionProvider) CreateVolumeDefinition(ctx context.Context, resDefName string, volDef client.VolumeDefinitionCreate) error {
	ret := _m.Called(ctx, resDefName, volDef)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, client.VolumeDefinitionCreate) error); ok {
		r0 = rf(ctx, resDefName, volDef)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, resDefName
func (_m *ResourceDefinitionProvider) Delete(ctx context.Context, resDefName string) error {
	ret := _m.Called(ctx, resDefName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, resDefName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteVolumeDefinition provides a mock function with given fields: ctx, resDefName, volNr
func (_m *ResourceDefinitionProvider) DeleteVolumeDefinition(ctx context.Context, resDefName string, volNr int) error {
	ret := _m.Called(ctx, resDefName, volNr)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) error); ok {
		r0 = rf(ctx, resDefName, volNr)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DetachExternalFile provides a mock function with given fields: ctx, resDefName, filePath
func (_m *ResourceDefinitionProvider) DetachExternalFile(ctx context.Context, resDefName string, filePath string) error {
	ret := _m.Called(ctx, resDefName, filePath)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, resDefName, filePath)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, resDefName, opts
func (_m *ResourceDefinitionProvider) Get(ctx context.Context, resDefName string, opts ...*client.ListOpts) (client.ResourceDefinition, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resDefName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 client.ResourceDefinition
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) client.ResourceDefinition); ok {
		r0 = rf(ctx, resDefName, opts...)
	} else {
		r0 = ret.Get(0).(client.ResourceDefinition)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, resDefName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAll provides a mock function with given fields: ctx, request
func (_m *ResourceDefinitionProvider) GetAll(ctx context.Context, request client.RDGetAllRequest) ([]client.ResourceDefinitionWithVolumeDefinition, error) {
	ret := _m.Called(ctx, request)

	var r0 []client.ResourceDefinitionWithVolumeDefinition
	if rf, ok := ret.Get(0).(func(context.Context, client.RDGetAllRequest) []client.ResourceDefinitionWithVolumeDefinition); ok {
		r0 = rf(ctx, request)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.ResourceDefinitionWithVolumeDefinition)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, client.RDGetAllRequest) error); ok {
		r1 = rf(ctx, request)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDRBDProxyPropsInfos provides a mock function with given fields: ctx, resDefName, opts
func (_m *ResourceDefinitionProvider) GetDRBDProxyPropsInfos(ctx context.Context, resDefName string, opts ...*client.ListOpts) ([]client.PropsInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resDefName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []client.PropsInfo
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) []client.PropsInfo); ok {
		r0 = rf(ctx, resDefName, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.PropsInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, resDefName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPropsInfos provides a mock function with given fields: ctx, opts
func (_m *ResourceDefinitionProvider) GetPropsInfos(ctx context.Context, opts ...*client.ListOpts) ([]client.PropsInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []client.PropsInfo
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) []client.PropsInfo); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.PropsInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVolumeDefinition provides a mock function with given fields: ctx, resDefName, volNr, opts
func (_m *ResourceDefinitionProvider) GetVolumeDefinition(ctx context.Context, resDefName string, volNr int, opts ...*client.ListOpts) (client.VolumeDefinition, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resDefName, volNr)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 client.VolumeDefinition
	if rf, ok := ret.Get(0).(func(context.Context, string, int, ...*client.ListOpts) client.VolumeDefinition); ok {
		r0 = rf(ctx, resDefName, volNr, opts...)
	} else {
		r0 = ret.Get(0).(client.VolumeDefinition)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, int, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, resDefName, volNr, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetVolumeDefinitions provides a mock function with given fields: ctx, resDefName, opts
func (_m *ResourceDefinitionProvider) GetVolumeDefinitions(ctx context.Context, resDefName string, opts ...*client.ListOpts) ([]client.VolumeDefinition, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, resDefName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 []client.VolumeDefinition
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) []client.VolumeDefinition); ok {
		r0 = rf(ctx, resDefName, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.VolumeDefinition)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, resDefName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Modify provides a mock function with given fields: ctx, resDefName, props
func (_m *ResourceDefinitionProvider) Modify(ctx context.Context, resDefName string, props client.GenericPropsModify) error {
	ret := _m.Called(ctx, resDefName, props)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, client.GenericPropsModify) error); ok {
		r0 = rf(ctx, resDefName, props)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ModifyVolumeDefinition provides a mock function with given fields: ctx, resDefName, volNr, props
func (_m *ResourceDefinitionProvider) ModifyVolumeDefinition(ctx context.Context, resDefName string, volNr int, props client.VolumeDefinitionModify) error {
	ret := _m.Called(ctx, resDefName, volNr, props)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, client.VolumeDefinitionModify) error); ok {
		r0 = rf(ctx, resDefName, volNr, props)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncStatus provides a mock function with given fields: ctx, resDef
func (_m *ResourceDefinitionProvider) SyncStatus(ctx context.Context, resDef string) (client.ResourceDefinitionSyncStatus, error) {
	ret := _m.Called(ctx, resDef)

	var r0 client.ResourceDefinitionSyncStatus
	if rf, ok := ret.Get(0).(func(context.Context, string) client.ResourceDefinitionSyncStatus); ok {
		r0 = rf(ctx, resDef)
	} else {
		r0 = ret.Get(0).(client.ResourceDefinitionSyncStatus)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, resDef)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type NewResourceDefinitionProviderT interface {
	mock.TestingT
	Cleanup(func())
}

// NewResourceDefinitionProvider creates a new instance of ResourceDefinitionProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewResourceDefinitionProvider(t NewResourceDefinitionProviderT) *ResourceDefinitionProvider {
	mock := &ResourceDefinitionProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
