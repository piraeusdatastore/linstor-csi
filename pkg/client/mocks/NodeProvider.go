// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	client "github.com/LINBIT/golinstor/client"

	mock "github.com/stretchr/testify/mock"
)

// NodeProvider is an autogenerated mock type for the NodeProvider type
type NodeProvider struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, node
func (_m *NodeProvider) Create(ctx context.Context, node client.Node) error {
	ret := _m.Called(ctx, node)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, client.Node) error); ok {
		r0 = rf(ctx, node)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateDevicePool provides a mock function with given fields: ctx, nodeName, psc
func (_m *NodeProvider) CreateDevicePool(ctx context.Context, nodeName string, psc client.PhysicalStorageCreate) error {
	ret := _m.Called(ctx, nodeName, psc)

	if len(ret) == 0 {
		panic("no return value specified for CreateDevicePool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, client.PhysicalStorageCreate) error); ok {
		r0 = rf(ctx, nodeName, psc)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateEbsNode provides a mock function with given fields: ctx, name, remoteName
func (_m *NodeProvider) CreateEbsNode(ctx context.Context, name string, remoteName string) error {
	ret := _m.Called(ctx, name, remoteName)

	if len(ret) == 0 {
		panic("no return value specified for CreateEbsNode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, name, remoteName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateNetInterface provides a mock function with given fields: ctx, nodeName, nif
func (_m *NodeProvider) CreateNetInterface(ctx context.Context, nodeName string, nif client.NetInterface) error {
	ret := _m.Called(ctx, nodeName, nif)

	if len(ret) == 0 {
		panic("no return value specified for CreateNetInterface")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, client.NetInterface) error); ok {
		r0 = rf(ctx, nodeName, nif)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateStoragePool provides a mock function with given fields: ctx, nodeName, sp
func (_m *NodeProvider) CreateStoragePool(ctx context.Context, nodeName string, sp client.StoragePool) error {
	ret := _m.Called(ctx, nodeName, sp)

	if len(ret) == 0 {
		panic("no return value specified for CreateStoragePool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, client.StoragePool) error); ok {
		r0 = rf(ctx, nodeName, sp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with given fields: ctx, nodeName
func (_m *NodeProvider) Delete(ctx context.Context, nodeName string) error {
	ret := _m.Called(ctx, nodeName)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, nodeName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNetinterface provides a mock function with given fields: ctx, nodeName, nifName
func (_m *NodeProvider) DeleteNetinterface(ctx context.Context, nodeName string, nifName string) error {
	ret := _m.Called(ctx, nodeName, nifName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNetinterface")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, nodeName, nifName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteStoragePool provides a mock function with given fields: ctx, nodeName, spName
func (_m *NodeProvider) DeleteStoragePool(ctx context.Context, nodeName string, spName string) error {
	ret := _m.Called(ctx, nodeName, spName)

	if len(ret) == 0 {
		panic("no return value specified for DeleteStoragePool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, nodeName, spName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Evacuate provides a mock function with given fields: ctx, nodeName, evacuate
func (_m *NodeProvider) Evacuate(ctx context.Context, nodeName string, evacuate *client.NodeEvacuate) error {
	ret := _m.Called(ctx, nodeName, evacuate)

	if len(ret) == 0 {
		panic("no return value specified for Evacuate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *client.NodeEvacuate) error); ok {
		r0 = rf(ctx, nodeName, evacuate)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Evict provides a mock function with given fields: ctx, nodeName
func (_m *NodeProvider) Evict(ctx context.Context, nodeName string) error {
	ret := _m.Called(ctx, nodeName)

	if len(ret) == 0 {
		panic("no return value specified for Evict")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, nodeName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, nodeName, opts
func (_m *NodeProvider) Get(ctx context.Context, nodeName string, opts ...*client.ListOpts) (client.Node, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, nodeName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 client.Node
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) (client.Node, error)); ok {
		return rf(ctx, nodeName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) client.Node); ok {
		r0 = rf(ctx, nodeName, opts...)
	} else {
		r0 = ret.Get(0).(client.Node)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, nodeName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAll provides a mock function with given fields: ctx, opts
func (_m *NodeProvider) GetAll(ctx context.Context, opts ...*client.ListOpts) ([]client.Node, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetAll")
	}

	var r0 []client.Node
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) ([]client.Node, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) []client.Node); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.Node)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetInterface provides a mock function with given fields: ctx, nodeName, nifName, opts
func (_m *NodeProvider) GetNetInterface(ctx context.Context, nodeName string, nifName string, opts ...*client.ListOpts) (client.NetInterface, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, nodeName, nifName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetInterface")
	}

	var r0 client.NetInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...*client.ListOpts) (client.NetInterface, error)); ok {
		return rf(ctx, nodeName, nifName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...*client.ListOpts) client.NetInterface); ok {
		r0 = rf(ctx, nodeName, nifName, opts...)
	} else {
		r0 = ret.Get(0).(client.NetInterface)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, nodeName, nifName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetInterfaces provides a mock function with given fields: ctx, nodeName, opts
func (_m *NodeProvider) GetNetInterfaces(ctx context.Context, nodeName string, opts ...*client.ListOpts) ([]client.NetInterface, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, nodeName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetNetInterfaces")
	}

	var r0 []client.NetInterface
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) ([]client.NetInterface, error)); ok {
		return rf(ctx, nodeName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) []client.NetInterface); ok {
		r0 = rf(ctx, nodeName, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.NetInterface)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, nodeName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPhysicalStorage provides a mock function with given fields: ctx, nodeName
func (_m *NodeProvider) GetPhysicalStorage(ctx context.Context, nodeName string) ([]client.PhysicalStorageNode, error) {
	ret := _m.Called(ctx, nodeName)

	if len(ret) == 0 {
		panic("no return value specified for GetPhysicalStorage")
	}

	var r0 []client.PhysicalStorageNode
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]client.PhysicalStorageNode, error)); ok {
		return rf(ctx, nodeName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []client.PhysicalStorageNode); ok {
		r0 = rf(ctx, nodeName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.PhysicalStorageNode)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, nodeName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPhysicalStorageView provides a mock function with given fields: ctx, opts
func (_m *NodeProvider) GetPhysicalStorageView(ctx context.Context, opts ...*client.ListOpts) ([]client.PhysicalStorageViewItem, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPhysicalStorageView")
	}

	var r0 []client.PhysicalStorageViewItem
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) ([]client.PhysicalStorageViewItem, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) []client.PhysicalStorageViewItem); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.PhysicalStorageViewItem)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPropsInfos provides a mock function with given fields: ctx, opts
func (_m *NodeProvider) GetPropsInfos(ctx context.Context, opts ...*client.ListOpts) ([]client.PropsInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetPropsInfos")
	}

	var r0 []client.PropsInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) ([]client.PropsInfo, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) []client.PropsInfo); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.PropsInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStoragePool provides a mock function with given fields: ctx, nodeName, spName, opts
func (_m *NodeProvider) GetStoragePool(ctx context.Context, nodeName string, spName string, opts ...*client.ListOpts) (client.StoragePool, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, nodeName, spName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStoragePool")
	}

	var r0 client.StoragePool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...*client.ListOpts) (client.StoragePool, error)); ok {
		return rf(ctx, nodeName, spName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...*client.ListOpts) client.StoragePool); ok {
		r0 = rf(ctx, nodeName, spName, opts...)
	} else {
		r0 = ret.Get(0).(client.StoragePool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, nodeName, spName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStoragePoolPropsInfos provides a mock function with given fields: ctx, nodeName, opts
func (_m *NodeProvider) GetStoragePoolPropsInfos(ctx context.Context, nodeName string, opts ...*client.ListOpts) ([]client.PropsInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, nodeName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStoragePoolPropsInfos")
	}

	var r0 []client.PropsInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) ([]client.PropsInfo, error)); ok {
		return rf(ctx, nodeName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) []client.PropsInfo); ok {
		r0 = rf(ctx, nodeName, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.PropsInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, nodeName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStoragePoolView provides a mock function with given fields: ctx, opts
func (_m *NodeProvider) GetStoragePoolView(ctx context.Context, opts ...*client.ListOpts) ([]client.StoragePool, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStoragePoolView")
	}

	var r0 []client.StoragePool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) ([]client.StoragePool, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...*client.ListOpts) []client.StoragePool); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.StoragePool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStoragePools provides a mock function with given fields: ctx, nodeName, opts
func (_m *NodeProvider) GetStoragePools(ctx context.Context, nodeName string, opts ...*client.ListOpts) ([]client.StoragePool, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, nodeName)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GetStoragePools")
	}

	var r0 []client.StoragePool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) ([]client.StoragePool, error)); ok {
		return rf(ctx, nodeName, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, ...*client.ListOpts) []client.StoragePool); ok {
		r0 = rf(ctx, nodeName, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]client.StoragePool)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, ...*client.ListOpts) error); ok {
		r1 = rf(ctx, nodeName, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Lost provides a mock function with given fields: ctx, nodeName
func (_m *NodeProvider) Lost(ctx context.Context, nodeName string) error {
	ret := _m.Called(ctx, nodeName)

	if len(ret) == 0 {
		panic("no return value specified for Lost")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, nodeName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Modify provides a mock function with given fields: ctx, nodeName, props
func (_m *NodeProvider) Modify(ctx context.Context, nodeName string, props client.NodeModify) error {
	ret := _m.Called(ctx, nodeName, props)

	if len(ret) == 0 {
		panic("no return value specified for Modify")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, client.NodeModify) error); ok {
		r0 = rf(ctx, nodeName, props)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ModifyNetInterface provides a mock function with given fields: ctx, nodeName, nifName, nif
func (_m *NodeProvider) ModifyNetInterface(ctx context.Context, nodeName string, nifName string, nif client.NetInterface) error {
	ret := _m.Called(ctx, nodeName, nifName, nif)

	if len(ret) == 0 {
		panic("no return value specified for ModifyNetInterface")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, client.NetInterface) error); ok {
		r0 = rf(ctx, nodeName, nifName, nif)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ModifyStoragePool provides a mock function with given fields: ctx, nodeName, spName, genericProps
func (_m *NodeProvider) ModifyStoragePool(ctx context.Context, nodeName string, spName string, genericProps client.GenericPropsModify) error {
	ret := _m.Called(ctx, nodeName, spName, genericProps)

	if len(ret) == 0 {
		panic("no return value specified for ModifyStoragePool")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, client.GenericPropsModify) error); ok {
		r0 = rf(ctx, nodeName, spName, genericProps)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Reconnect provides a mock function with given fields: ctx, nodeName
func (_m *NodeProvider) Reconnect(ctx context.Context, nodeName string) error {
	ret := _m.Called(ctx, nodeName)

	if len(ret) == 0 {
		panic("no return value specified for Reconnect")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, nodeName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Restore provides a mock function with given fields: ctx, nodeName, restore
func (_m *NodeProvider) Restore(ctx context.Context, nodeName string, restore client.NodeRestore) error {
	ret := _m.Called(ctx, nodeName, restore)

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, client.NodeRestore) error); ok {
		r0 = rf(ctx, nodeName, restore)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewNodeProvider creates a new instance of NodeProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewNodeProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *NodeProvider {
	mock := &NodeProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
